version: '3'

vars:
  CURRENT_BRANCH:
    sh: git rev-parse --abbrev-ref HEAD
  LOCAL_CHANGES:
    sh: git diff --name-only HEAD | awk -F'/' '/^modules\// {print $2}' | sort -u | tr '\n' ' '
  UNPUSHED_COMMITS:
    sh: git diff --name-only origin/{{.CURRENT_BRANCH}}...HEAD | awk -F'/' '/^modules\// {print $2}' | sort -u | tr '\n' ' '
  IS_CI:
    sh: 'test -n "$CIRCLECI" && echo "true" || echo "false"'

  # Determines which modules have changed compared to the main branch.
  CHANGED_MODULES:
    sh: |
      set -o pipefail
      if [ -n "$CIRCLE_SHA1" ]; then
        git diff-tree --no-commit-id --name-only -r "$CIRCLE_SHA1" | awk -F'/' '/^modules\// {print $2}' | sort -u | while read -r module; do if [ -d "modules/$module" ]; then echo "$module"; fi; done | tr '\n' ' '
      else
        git diff --name-only master... | awk -F'/' '/^modules\// {print $2}' | sort -u | while read -r module; do if [ -d "modules/$module" ]; then echo "$module"; fi; done | tr '\n' ' '
      fi

  # Lists all available modules based on the modules/ directory.
  ALL_MODULES:
    sh: find modules -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | LC_ALL=C sort | tr '\n' ' '

tasks:
  fetch-merge:
    desc: git fetch and merge
    cmds:
      - 'git fetch && git merge origin/master'
  print:
    desc: Print changed
    cmds:
      - 'echo "Changed modules: {{.CHANGED_MODULES}}"'
      - 'echo "Current branch: "{{.CURRENT_BRANCH}}""'
      - 'echo "Local Chanegs: {{.LOCAL_CHANGES}}"'
      - 'echo "Unpushued Changes: {{.UNPUSHED_COMMITS}}"'

  default:
    desc: "Lists all available tasks."
    cmds:
      - task --list-all

  # --- CI/CD TASKS (for changed modules) ---

  validate-local:
    desc: "Validates modules with uncommitted local changes."
    preconditions:
      - sh: '[ -n "{{.LOCAL_CHANGES}}" ]'
        msg: "✅ No uncommitted local changes detected in any modules."
    cmds:
      - for: { var: LOCAL_CHANGES }
        task: validate-module
        vars:
          module: '{{.ITEM}}'

  validate-unpushed:
    desc: "Validates modules with committed but unpushed changes."
    preconditions:
      - sh: '[ -n "{{.UNPUSHED_COMMITS}}" ]'
        msg: "✅ No unpushed commits detected in any modules."
    cmds:
      - for: { var: UNPUSHED_COMMITS }
        task: validate-module
        vars:
          module: '{{.ITEM}}'

  validate-changed:
    desc: "Validates modules that have changed since the 'main' branch."
    preconditions:
      - sh: '[ -n "{{.CHANGED_MODULES}}" ]'
        msg: "✅ No changed modules detected. Nothing to validate."
    cmds:
      - for: { var: CHANGED_MODULES }
        task: validate-module
        vars:
          module: '{{.ITEM}}'
  
  check-docs:
    desc: "Checks if the committed documentation is up-to-date."
    cmds:
      - task: docs
      - |
        if ! git diff --quiet --exit-code; then
          echo "Documentation is out of date. Please run 'task docs' and commit the changes."
          git diff
          exit 1
        fi

  # --- MANUAL TASKS ---

  validate-all:
    desc: "Validates all Terraform modules."
    cmds:
      - for: { var: ALL_MODULES }
        task: validate-module
        vars:
          module: '{{.ITEM}}'
  
  init-all:
    desc: "Init all Terraform modules."
    cmds:
      - for: { var: ALL_MODULES }
        task: init-module
        vars:
          module: '{{.ITEM}}'

  # --- UTILITY & DOCUMENTATION TASKS ---

  fmt:
    desc: "Formats all Terraform files recursively."
    cmds:
      - terraform fmt -recursive

  clean:
    desc: "Removes all Terraform cache (.terraform) files."
    cmds:
      - find . -type d -name ".terraform" -exec rm -rf {} +

  docs:
    desc: "Generates READMEs for all modules and a master index."
    cmds:
      # This single command handles the interactive prompt.
      - |
        if test {{.IS_CI}} = false; then
          printf "This will overwrite existing README files. Are you sure? [y/N] "
          read -r answer
          if [ "$answer" != "y" ] && [ "$answer" != "Y" ]; then
            echo "Aborted."
            exit 1
          fi
        fi
      - echo "# Terraform Modules" > ./modules/README.md
      - for: { var: ALL_MODULES }
        task: doc-module
        vars:
          MODULE: '{{.ITEM}}'
      - echo "## [Back](../README.md)" >> ./modules/README.md

  # --- Add this new internal helper task ---
  _prompt-confirm:
    internal: true
    prompt: "This will overwrite existing README files. Are you sure? [y/N]"

  doc-root:
    desc: "Generates the root README.md file with a dynamic list of modules."
    cmds:
      - |
        if test {{.IS_CI}} = false; then
          printf "This will overwrite existing README files. Are you sure? [y/N] "
          read -r answer
          if [ "$answer" != "y" ] && [ "$answer" != "Y" ]; then
            echo "Aborted."
            exit 1
          fi
        fi
      - task: doc-root-header
      - for: { var: ALL_MODULES }
        task: doc-root-module-link
        vars:
          MODULE: '{{.ITEM}}'
      - task: doc-root-footer
  

  # --- INTERNAL HELPER TASKS ---

  doc-root-header:
    internal: true
    cmds:
      - |
        echo -e "# Terraform AWS Modules\n\nThis repository contains a collection of reusable, production-ready Terraform modules for provisioning infrastructure on Amazon Web Services (AWS). Each module is designed to be a focused, configurable, and self-contained unit of infrastructure.\n\nThe primary goal of this repository is to enforce consistency, follow best practices, and accelerate the process of building new services.\n\n## Available Modules\n\nBelow is a list of the modules available in this repository. For detailed information on the inputs, outputs, and usage of a specific module, please refer to the \`README.md\` file within its directory." > README.md

  doc-root-module-link:
    internal: true
    cmd: 'echo -e "* [\`{{.MODULE}}\`](./modules/{{.MODULE}}/README.md)" >> README.md'
    requires:
      vars: [MODULE]
  
  doc-root-footer:
    internal: true
    cmds:
      - |
        echo -e "\n## Usage\n\nThese modules are intended to be consumed by other Terraform projects (like a services repository). You can use them by referencing their path directly in your service's Terraform code.\n\n### Example: Creating a Static Website\n\n\`\`\`hcl\n# In a service's main.tf file\n\n# 1. Look up the existing DNS zone\ndata \"aws_route53_zone\" \"this\" {\n  name = \"example.com\"\n}\n\n# 2. Provision the S3 bucket for the site content\nmodule \"s3_site\" {\n  source      = \"../../terraform-modules/modules/s3-static-site\"\n  bucket_name = \"www.example.com\"\n  tags        = { Environment = \"production\" }\n}\n\n# 3. Provision the CloudFront distribution\nmodule \"cloudfront\" {\n  source                  = \"../../terraform-modules/modules/cloudfront\"\n  s3_origin_domain_name   = module.s3_site.website_endpoint\n  s3_origin_id            = module.s3_site.bucket_id\n  domain_name             = \"example.com\"\n  acm_certificate_arn     = \"arn:aws:acm:us-east-1:123456789012:certificate/your-cert-id\"\n}\n\n# 4. Create the DNS records\nmodule \"dns_records\" {\n  source        = \"../../terraform-modules/modules/route53-record\"\n  zone_id       = data.aws_route53_zone.this.zone_id\n  domain_name   = \"example.com\"\n  record_names  = [\"@\", \"www\"]\n  \n  alias_name    = module.cloudfront.domain_name\n  alias_zone_id = module.cloudfront.hosted_zone_id\n}\n\`\`\`\n\n## Development and Maintenance\n\nThis repository uses [Task](https://taskfile.dev/) for automation and quality control. The following commands are available for module development:\n\n* \`task fmt\`: Formats all Terraform code in the repository.\n* \`task validate-all\`: Initializes and validates every module to ensure its syntax is correct.\n* \`task docs\`: Automatically generates or updates the \`README.md\` for all modules using \`terraform-docs\`.\n\nTo see a full list of available commands, run \`task --list-all\`." >> README.md

  init-module:
    internal: true
    cmds:
      - 'echo "--- Initializing: {{.module}} ---"'
      - terraform -chdir=./modules/{{.module}}/ init
    requires:
      vars: [module]

  validate-module:
    internal: true
    deps:
      - task: init-module
        vars: { module: "{{.module}}" }
    cmds:
      - 'echo "--- Validating: {{.module}} ---"'
      - terraform -chdir=./modules/{{.module}}/ validate
    requires:
      vars: [module]

  doc-module:
    internal: true
    cmds:
      - echo "* [{{.MODULE}}](./{{.MODULE}}/README.md)" >> ./modules/README.md
      - terraform-docs md table ./modules/{{.MODULE}} > ./modules/{{.MODULE}}/README.md
    requires:
      vars: [MODULE]
